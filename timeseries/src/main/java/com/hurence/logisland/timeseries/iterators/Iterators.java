/**
 * Copyright (C) 2016 Hurence (support@hurence.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hurence.logisland.timeseries.iterators;


import com.hurence.logisland.timeseries.dts.Pair;
import com.hurence.logisland.timeseries.dts.WeakLogic;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.*;

import static com.hurence.logisland.timeseries.dts.Pair.pairOf;
import static java.util.Arrays.asList;

/**
 * @author johannes.siedersleben
 */
public final class Iterators {

    /**
     * Private default constructor.
     */
    private Iterators() {
    }

    /**
     * @param xs  the values to be iterated over
     * @param <T> any type
     * @return an iterator yielding xs
     */
    public static <T> ImmutableIterator<T> of(T... xs) {
        return new ImmutableIterator<T>() {
            private int cnt = 0;

            @Override
            public boolean hasNext() {
                return cnt < xs.length;
            }

            @Override
            public T next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                return xs[cnt++];
            }
        };
    }

    /**
     * @param xs  an Iterable
     * @param <T> any type
     * @return xs as ImmutableIterator
     */
    public static <T> ImmutableIterator<T> asIterator(Iterable<T> xs) {
        return new ImmutableIterator<T>() {
            private Iterator<? extends T> t = xs.iterator();

            @Override
            public boolean hasNext() {
                return t.hasNext();
            }

            @Override
            public T next() {
                return t.next();
            }
        };
    }

    /**
     * @param x   the element to be repeated, may be null
     * @param n   the number of repetitions
     * @param <T> any type
     * @return an iterator repeating x n times
     */
    public static <T> ImmutableIterator<T> repeat(T x, int n) {
        return new Repeat<>(x, n);
    }

    /**
     * @param x   the element to be repeated, may be null
     * @param <T> any type
     * @return an iterator repeating x infinitely often
     */
    public static <T> InfiniteIterator<T> repeat(T x) {
        return () -> x;
    }

    /**
     * @param <T> any type
     * @return an empty iterator
     */
    public static <T> ImmutableIterator<T> empty() {
        return new Repeat<>(null, 0);
    }

    /**
     * @param <T>     any type
     * @param element any element, even null
     * @return an empty iterator
     */
    public static <T> ImmutableIterator<T> of(T element) {
        return new Repeat<>(element, 1);
    }

    /**
     * @param <T> any type
     * @param sp  any supplier
     * @return the iterator generated by suppl
     */
    public static <T> InfiniteIterator<T> generate(Supplier<T> sp) {
        return sp::get;
    }

    /**
     * @param <T> any type
     * @param ts  iterators to be concatenated
     * @return the concatenation of all t in ts
     */
    public static <T> ImmutableIterator<T> concat(Iterator<T>... ts) {
        if (ts.length < 1) {
            return empty();
        }

        return new ImmutableIterator<T>() {
            private int cnt = 0;

            @Override
            public boolean hasNext() {
                return (cnt < ts.length && ts[cnt].hasNext()) ||
                        (++cnt < ts.length && ts[cnt].hasNext());
            }

            @Override
            public T next() {
                if (hasNext()) {
                    return ts[cnt].next();
                } else {
                    throw new NoSuchElementException();
                }
            }
        };
    }

    /**
     * @param <T> any type
     * @param xs  the objects to be cycled on
     * @return an iterator cycling on xs
     */
    public static <T> InfiniteIterator<T> cycle(T... xs) {
        if (xs.length < 1) {
            throw new IllegalArgumentException("cycle requires at least one argument");

        }
        return new InfiniteIterator<T>() {
            private int cnt = 0;

            @Override
            public T next() {
                int index = cnt++ % xs.length;
                if (index >= xs.length) {
                    throw new NoSuchElementException();
                }
                return xs[index];
            }
        };
    }

    /**
     * @param t   the iterator to be accessed, may contain nulls
     * @param n   the number of elements to be read
     * @param <T> any type
     * @return a list containing the first n elements of t
     * or all elements of t if there are not more than n.
     */
    public static <T> List<T> take(Iterator<T> t, int n) {
        ArrayList<T> result = new ArrayList<>(n);
        int count = 0;
        while (t.hasNext() && count++ < n) {
            result.add(t.next());
        }
        return result;
    }

    /**
     * @param t   the iterator to be accessed, may contain null.
     * @param <T> any type
     * @return a list containing all elements of t.
     * Warning: infinite iterators yield an infinite loop
     */
    public static <T> List<T> takeAll(Iterator<T> t) {
        ArrayList<T> result = new ArrayList<>();
        while (t.hasNext()) {
            result.add(t.next());
        }
        return result;
    }

    /**
     * @param t   the iterator to be accessed, may contain null.
     * @param n   the number of elements to be considered
     * @param <T> any type
     * @return an iterator containing at most n elements
     */

    public static <T> ImmutableIterator<T> limit(Iterator<T> t, int n) {
        return new ImmutableIterator<T>() {
            private int count = 0;

            @Override
            public boolean hasNext() {
                return t.hasNext() && count < n;
            }

            @Override
            public T next() {
                if (count == n) {
                    throw new NoSuchElementException();
                } else {
                    count++;
                    return t.next();
                }
            }
        };
    }

    /**
     * @param xs  the list to be iterated on
     * @param <T> any type
     * @return an iterator iterating xs backwards
     */
    public static <T> ImmutableIterator<T> reverse(List<T> xs) {
        return new ImmutableIterator<T>() {
            private int cursor = xs.size();

            @Override
            public boolean hasNext() {
                return cursor > 0;
            }

            @Override
            public T next() {
                return xs.get(--cursor);
            }
        };
    }

    /**
     * @param t   the iterator
     * @param cs  the consumer to be applied
     * @param <T> any type
     * @return an iterator which applies cs to each object before returning it
     */
    public static <T> ImmutableIterator<T> peek(Iterator<T> t, Consumer<? super T> cs) {
        return new ImmutableIterator<T>() {

            @Override
            public boolean hasNext() {
                return t.hasNext();
            }

            @Override
            public T next() {
                T x = t.next();
                cs.accept(x);
                return x;
            }
        };
    }

    /**
     * @param from   the iterator to be mapped, may contain nulls.
     * @param mapper the function to be applied to each element
     * @param <F>    the type from which will be mapped
     * @param <T>    the type to which will be mapped
     * @return the iterator of mapped elements
     */
    public static <F, T> ImmutableIterator<T> map(Iterator<F> from, Function<? super F, ? extends T> mapper) {
        return new ImmutableIterator<T>() {

            @Override
            public boolean hasNext() {
                return from.hasNext();
            }

            @Override
            public T next() {
                return mapper.apply(from.next());
            }
        };
    }

    /**
     * @param first  the first iterator to be mapped, may contain nulls
     * @param second the second iterator to be mapped, may contain nulls
     * @param mapper the function to be applied to each pair of elements from first and second
     * @param <T>    the type to which will be mapped
     * @return the iterator of mapped elements
     */
    public static <T> ImmutableIterator<T> map(Iterator<T> first,
                                               Iterator<T> second,
                                               BinaryOperator<T> mapper) {
        ImmutableIterator<List<T>> aux = zip(asList(first, second));
        return map(aux, (List<T> xs) -> mapper.apply(xs.get(0), xs.get(1)));
    }

    /**
     * @param t   the iterator to be consumed; nulls are skipped
     * @param acc accumulator: the operator to be applied
     * @param <T> any type
     * @return the result
     */
    public static <T> T reduce(Iterator<T> t, BinaryOperator<T> acc) {
        T result = t.next();
        while (t.hasNext()) {
            T x = t.next();
            if (x != null) {
                result = acc.apply(result, x);
            }
        }
        return result;
    }


    /**
     * @param t    the iterator to be reduced
     * @param acc  the accumulator function
     * @param seed the start value
     * @param <T>  any type
     * @param <V>  any type
     * @return the reduced value
     */
    public static <T, V> V reduce(Iterator<T> t, BiFunction<V, T, V> acc, V seed) {
        V result = seed;
        while (t.hasNext()) {
            T x = t.next();
            if (x != null && result != null) {
                result = acc.apply(result, x);
            }
        }
        return result;
    }


    /**
     * @param iterators the iterators to be merged. They must be sorted.
     * @param weak      if weak == false the merged iterator it stops when the first input iterator does.
     *                  if weak == true it stops when the last input iterator does.
     * @param <T>       any comparable type
     * @return the merged iterator
     */
    public static <T extends Comparable<T>> ImmutableIterator<T>
    merge(List<Iterator<T>> iterators, boolean weak) {
        Function<List<T>, Integer> min = xs -> {
            int m = -1;
            for (int i = 0; i < xs.size(); i++) {
                if (xs.get(i) == null) {
                    continue;
                }
                if (m < 0 || xs.get(i).compareTo(xs.get(m)) < 0) {
                    m = i;
                }
            }
            return m;
        };

        return new Merge<>(iterators, min, weak);
    }

    /**
     * @param from  is being cloned
     * @param forks the number of forks
     * @return list of n iterator clones to be iterated on independently
     * After calling tee, from must not be iterated on!
     */
    public static <T> List<ImmutableIterator<T>> tee(Iterator<T> from, int forks) {
        return new Tee<>(from, forks).iterators();
    }

    /**
     * @param <T> any type
     * @param ts  list of iterators
     * @return iterator of lists: the n-th element is the list of all
     * n-th elements of the input iterators. The result stops iff the last
     * input iterator is exhausted
     */

    public static <T> ImmutableIterator<List<T>> zip(List<Iterator<T>> ts) {
        return new Zip<>(ts, true);
    }


    /**
     * weak = true  : stop at the last exhausted iterator
     * weak = false : stop at the first exhausted iterator
     *
     * @param <T>  any type
     * @param ts   list of iterators
     * @param weak see above
     * @return iterator of lists: the n-th element is the list of all
     * n-th elements of the input iterators.
     * weak = true  : stop at the last exhausted iterator
     * weak = false : stop at the first exhausted iterator
     */

    public static <T> ImmutableIterator<List<T>> zip(List<Iterator<T>> ts, boolean weak) {
        return new Zip<>(ts, weak);
    }

    /**
     * @param <T>            any type
     * @param zippedIterator iterator of lists; must not be empty.
     *                       The lists are typically but not necessarily
     *                       of equal size.
     * @return list of iterators to be iterated on independently
     * The result's size is that of the first list; subsequent lists
     * are truncated if longer and padded with nulls if shorter
     */
    public static <T> List<ImmutableIterator<T>> unzip(Iterator<List<T>> zippedIterator) {
        List<T> firstColumn = zippedIterator.next();
        int n = firstColumn.size();

        @SuppressWarnings("unchecked") List<ImmutableIterator<List<T>>> aux = tee(concat(of(firstColumn), zippedIterator), n);
        List<ImmutableIterator<T>> result = new ArrayList<>(n);

        for (int i = 0; i < n; i++) {
            int j = i;    // j is effectively final, i is not
            result.add(j, map(aux.get(j), xs -> j < xs.size() ? xs.get(j) : null));
        }
        return result;
    }

    /**
     * weak = true  : stop at the last exhausted iterator
     * weak = false : stop at the first exhausted iterator
     *
     * @param <A>       any type
     * @param <B>       any type
     * @param iterators a pair of iterators
     * @param weak      see above
     * @return an iterator of pairs
     */
    public static <A, B> ImmutableIterator<Pair<A, B>>
    zip(Pair<Iterator<A>, Iterator<B>> iterators, boolean weak) {
        List input = iterators.asList();
        Iterator<List> output = zip(input, weak);      // no way to avoid warnings
        return map(output, (List xs) -> pairOf((A) xs.get(0), (B) xs.get(1)));
    }

    /**
     * @param iterator the iterator to be iterated over
     * @param key      the function defining what duplicates are
     * @param <T>      any type
     * @return an iterator skipping consecutive duplicates
     * Elements x, y are duplicates
     * iff weakEquals(key.apply(x), (key.apply(y)) is true.
     * Of n consecutive equal elements, the first one is retained.
     */
    public static <T, K> ImmutableIterator<T>
    skipDuplicates(Iterator<T> iterator, Function<? super T, ? extends K> key) {
        return new SkipDuplicates<>(iterator, key, true);
    }

    /**
     * @param iterator the iterator to be iterated over
     * @param key      the function defining what duplicates are
     * @param <T>      any type
     * @return an iterator skipping consecutive duplicates
     * Elements x, y are duplicates
     * iff weakEquals(key.apply(x), (key.apply(y)) is true.
     * Of n consecutive equal elements, the first one is retained.
     */
    public static <T, K> ImmutableIterator<T>
    keepFirst(Iterator<T> iterator, Function<? super T, ? extends K> key) {
        return new SkipDuplicates<>(iterator, key, true);
    }

    /**
     * @param iterator the iterator to be iterated over
     * @param key      the function defining what duplicates are
     * @param <T>      any type
     * @return an iterator skipping consecutive duplicates
     * Elements x, y are duplicates
     * iff weakEquals(key.apply(x), (key.apply(y)) is true.
     * Of n consecutive equal elements, the last one is retained.
     */
    public static <T, K> ImmutableIterator<T>
    keepLast(Iterator<T> iterator, Function<? super T, ? extends K> key) {
        return new SkipDuplicates<>(iterator, key, false);
    }


    /**
     * @param iterator the iterator to be iterated over
     * @param <T>      any type
     * @return an iterator skipping consecutive duplicates
     * thus: 1 1 2 2 3 3 3 4 produces 1 2 3 4
     * but:  1 2 3 4 1 2 3 4 produces 1 2 3 4 1 2 3 4
     * Of n consecutive equal elements, the first one is retained.
     * Warning:    If the input iterator contains infinitely many
     * consecutive equal elements, next() will loop indefinitely
     */
    public static <T> ImmutableIterator<T> skipDuplicates(Iterator<T> iterator) {
        return new SkipDuplicates<>(iterator, x -> x, true);
    }

    /**
     * @param iterator the iterator to be iterated over
     * @param <T>      any type
     * @return an iterator skipping consecutive duplicates
     * thus: 1 1 2 2 3 3 3 4 produces 1 2 3 4
     * but:  1 2 3 4 1 2 3 4 produces 1 2 3 4 1 2 3 4
     * Of n consecutive equal elements, the first one is retained.
     * Warning:    If the input iterator contains infinitely many
     * consecutive equal elements, next() will loop indefinitely
     */
    public static <T> ImmutableIterator<T> keepFirst(Iterator<T> iterator) {
        return new SkipDuplicates<>(iterator, x -> x, true);
    }

    /**
     * @param iterator the iterator to be iterated over
     * @param <T>      any type
     * @return an iterator skipping consecutive duplicates
     * thus: 1 1 2 2 3 3 3 4 produces 1 2 3 4
     * but:  1 2 3 4 1 2 3 4 produces 1 2 3 4 1 2 3 4
     * Of n consecutive equal elements, the last one is retained.
     * Warning:    If the input iterator contains infinitely many
     * consecutive equal elements, next() will loop indefinitely
     */
    public static <T> ImmutableIterator<T> keepLast(Iterator<T> iterator) {
        return new SkipDuplicates<>(iterator, x -> x, false);
    }

    /**
     * This function groups an iterator by a key function:
     * consecutive elements with the same key value form a group.
     * The result is an Iterator of Lists of objects
     * Example: 4 7 10 5 8 11 3, key(x) = x%3 produces ((4 7 10) (5 8 11) (3))
     *
     * @param iterator the iterator to be grouped. May contain nulls.
     * @param key      the key function controlling the grouping
     * @param <T>      any type
     * @param <V>      any type
     * @return the grouped iterator
     */
    public static <T, V> ImmutableIterator<List<T>> groupBy(Iterator<T> iterator, Function<T, V> key) {
        return new GroupBy<>(iterator, key);
    }

    /**
     * This function groups an iterator.
     * consecutive elements which are equal form a group.
     * The result is an Iterator of List of objects.
     * Example: x x x y y z produces ((x x x) (y y) (z))
     *
     * @param iterator the iterator to be grouped. May contain nulls.
     * @param <T>      any type
     * @return the grouped iterator
     */
    public static <T> ImmutableIterator<List<T>> groupBy(Iterator<T> iterator) {
        return new GroupBy<>(iterator, x -> x);
    }

    /**
     * @param first  first iterator to be compared
     * @param second second iterator to be compared
     * @param n      maximum number of elements to be compared
     * @param <T>    any type
     * @return true if the first n elements of each iterator are equal or
     * if the iterators have equal length < n and all of their elements are equal
     * this method accepts iterators yielding nulls.
     */
    public static <T> boolean weakEquals(Iterator<? extends T> first, Iterator<? extends T> second, int n) {
        if (first.equals(second)) {
            return true;
        }
        for (int i = 0; i < n; i++) {
            if (!first.hasNext() && !second.hasNext()) {        // equal length
                return true;
            } else if (first.hasNext() && !second.hasNext()) {  // unequal length
                return false;
            } else if (!first.hasNext() && second.hasNext()) {  // unequal length
                return false;
            } else if (!WeakLogic.weakEquals(first.next(), second.next())) {  // both have next
                return false;
            }
        }
        return true;
    }

    /**
     * @param t   the iterator to be tested
     * @param p   the predicate to be applied
     * @param <T> any type
     * @return true iff at least one x in t satisfies p
     */
    public static <T> boolean any(Iterator<T> t, Predicate<? super T> p) {
        while (t.hasNext()) {
            if (p.test(t.next())) {
                return true;
            }
        }
        return false;
    }

    /**
     * @param xs  the iterable to be tested
     * @param p   the predicate to be applied
     * @param <T> any type
     * @return true iff at least one x in xs satisfies p
     */
    public static <T> boolean any(Iterable<T> xs, Predicate<? super T> p) {
        return any(xs.iterator(), p);
    }

    /**
     * @param xs  the iterable to be tested
     * @param p   the predicate to be applied
     * @param <T> any type
     * @return true iff all x in xs satisfy p
     */
    public static <T> boolean all(Iterable<T> xs, Predicate<? super T> p) {
        return all(xs.iterator(), p);
    }

    /**
     * @param t   the iterator to be tested
     * @param p   the predicate to be applied
     * @param <T> any type
     * @return true iff all x in t satisfy p
     */
    public static <T> boolean all(Iterator<T> t, Predicate<? super T> p) {
        while (t.hasNext()) {
            if (!p.test(t.next())) {
                return false;
            }
        }
        return true;
    }

    /**
     * @param xs  the iterable to be tested
     * @param p   the predicate to be applied
     * @param <T> any type
     * @return all elements of xs which satisfy p
     */
    public static <T> ImmutableIterator filter(Iterable<T> xs, Predicate<? super T> p) {
        return filter(xs.iterator(), p);
    }

    /**
     * @param t   the iterator to be filtered
     * @param p   the predicate to be applied
     * @param <T> any type
     * @return all elements of t which satisfy p
     */
    public static <T> ImmutableIterator filter(Iterator<T> t, Predicate<? super T> p) {
        return new FilteredIterator<>(t, p);
    }

    /**
     * @param v first element returned
     * @param f any unary operator
     * @return x, f(x), f(f(x)), ...
     */
    public static <T> InfiniteIterator<T> unaryGenerator(T v, UnaryOperator<T> f) {
        return new InfiniteIterator<T>() {
            private boolean first = true;
            private T val = v;

            @Override
            public T next() {
                if (first) {
                    first = false;
                } else {
                    val = f.apply(val);
                }
                return val;
            }
        };
    }

    /**
     * @param v first element returned
     * @param w second element returned
     * @param f a binary operator
     * @return x, y, f(x, y), f(y, f(x, y)), ...
     */
    public static <T> InfiniteIterator<T> binaryGenerator(T v, T w, BinaryOperator<T> f) {
        return new InfiniteIterator<T>() {
            private boolean first = true;
            private boolean second = true;
            private T firstVal = v;
            private T secondVal = w;

            @Override
            public T next() {
                if (first) {
                    first = false;
                    return firstVal;
                } else if (second) {
                    second = false;
                    return secondVal;
                } else {
                    T result = f.apply(firstVal, secondVal);
                    firstVal = secondVal;
                    secondVal = result;
                    return result;
                }
            }
        };
    }

    private static class FilteredIterator<T> implements ImmutableIterator {
        private final Iterator<T> t;
        private final Predicate<? super T> p;
        private boolean hasNext;
        private T current;
        private boolean initialized;

        FilteredIterator(Iterator<T> t, Predicate<? super T> p) {
            this.t = t;
            this.p = p;
            initialized = false;
        }

        private void search() {
            initialized = true;
            hasNext = false;
            while (t.hasNext()) {
                current = t.next();
                if (p.test(current)) {
                    hasNext = true;     // and current is the next item to be returned
                    break;
                }
            }
        }

        @Override
        public boolean hasNext() {
            if (!initialized) {
                search();
            }
            return hasNext;
        }

        @Override
        public T next() {
            if (!initialized) {
                search();
            }
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            T result = current;
            hasNext = false;
            search();
            return result;
        }
    }
}



